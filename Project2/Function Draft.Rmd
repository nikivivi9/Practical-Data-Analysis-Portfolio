---
title: "Function Draft"
author: "Yingxi Kong"
output: pdf_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# load necessary packages
library(tidyverse)
library(mice)
library(gt)
library(gtsummary)
library(kableExtra)
library(RColorBrewer)
library(scico)
library(caret)
library(glmnet)
library(pROC)
library(predtools)
library(gridExtra)
library(ggpubr)
library(patchwork)
```


```{r}
# set working directory
# Windows
# setwd("C:/Users/yingx/OneDrive/Desktop/Fall 2024/PHP 2550/Data/")

# Mac
setwd("~/Desktop/Fall 2024/PHP 2550/Data/")

# read in data
data <- read.csv("project2.csv")

data[, c("abst", "Var", "BA", "sex_ps", "NHW", 
         "Black", "Hisp", "inc", "edu", "ftcd.5.mins", 
         "otherdiag", "antidepmed", "mde_curr", 
         "Only.Menthol")] <- lapply(data[, c("abst", "Var", "BA", "sex_ps", "NHW", 
                                             "Black", "Hisp", "inc", "edu", 
                                             "ftcd.5.mins", "otherdiag", "antidepmed", 
                                             "mde_curr", "Only.Menthol")], as.factor)

new_data <- data %>%
  mutate(race = as.factor(case_when(Black == 0 & Hisp == 0 & NHW == 0 ~ "Unknown",
                                    Black == 1 & Hisp == 1 & NHW == 1 ~ "Mixed Race",
                                    Black == 1 & Hisp == 1 ~ "Mixed Race",
                                    Black == 1 & NHW == 1 ~ "Mixed Race",
                                    NHW == 1 & Hisp == 1 ~ "Mixed Race",
                                    Black == 1 ~ "Black",
                                    Hisp == 1 ~ "Hispanic",
                                    NHW == 1 ~ "Non-Hispanic White",
                                    TRUE ~ "Other")),
         trt = as.factor(case_when(Var == 1 & BA == 1 ~ "BASC + varenicline",
                         Var == 0 & BA == 1 ~ "BASC + placebo",
                         Var == 1 & BA == 0 ~ "ST + varenicline",
                         Var == 0 & BA == 0 ~ "ST + placebo",
                         TRUE ~ NA_character_)),
         inc = fct_recode(as.factor(inc), 
                          "Less than $20,000" = "1", 
                          "$20,000-35,000" = "2", 
                          "$35,001-50,000" = "3", 
                          "$50,001-75,000" = "4", 
                          "More than $75,000" = "5"),
         edu = fct_recode(as.factor(edu), 
                          "Grade School" = "1", 
                          "Some high school" = "2", 
                          "High school graduate or GED" = "3", 
                          "Some college/technical school" = "4", 
                          "College graduate" = "5"))

new_data <- new_data %>%
  mutate(inc = fct_relevel(inc, "Less than $20,000", "$20,000-35,000", 
                           "$35,001-50,000", "$50,001-75,000", "More than $75,000"),
         edu = fct_relevel(edu, "Grade School", "Some high school", "High school graduate or GED",
                           "Some college/technical school", "College graduate"))
```

```{r}
# multiple imputation with m = 5
imputed_data <- mice(new_data, m = 5, method = 'pmm', maxit = 50, seed = 2550, printFlag = FALSE)

# extract the five imputed datasets
completed_datasets <- list()
for (i in 1:5) {
  completed_datasets[[i]] <- complete(imputed_data, i)
}
```

```{r}
# lasso model function
lasso_model_function <- function(data_list) {
  lasso_coef <- list()
  
  for (index in seq_along(data_list)) {
    # extract data
    data <- data_list[[index]]
    
    # split train and test sets
    set.seed(2550)
    train_index <- createDataPartition(new_data$trt, p = 0.7, list = FALSE)
    train_data <- data[train_index, ]
    test_data <- data[-train_index, ]
    
    # create fold ids for cross-validation
    train_data$foldid <- NA
    for (trt_level in unique(train_data$trt)) {
      treatment_data <- train_data[train_data$trt == trt_level, ]
      fold_ids <- sample(rep(1:10, length.out = nrow(treatment_data)))
      train_data$foldid[train_data$trt == trt_level] <- fold_ids
    }
    
    # define model matrix
    X <- model.matrix(abst ~ trt * (age_ps + sex_ps + inc + edu + ftcd_score + ftcd.5.mins +
                                    bdi_score_w00 + cpd_ps + crv_total_pq1 + hedonsum_n_pq1 + hedonsum_y_pq1 +
                                    shaps_score_pq1 + otherdiag + antidepmed + mde_curr + NMR + Only.Menthol +
                                    readiness + race), data = train_data)[, -1]
    y <- train_data$abst
    
    # fit lasso with cross-validation using custom foldid
    cv_model <- cv.glmnet(X, y, family = "binomial", alpha = 1, foldid = train_data$foldid)
    best_lambda <- cv_model$lambda.min
    
    # fit the final lasso model using the best lambda
    lasso_model <- glmnet(X, y, family = "binomial", alpha = 1, lambda = best_lambda)
    
    # extract coefficients and store in a data frame
    coefficients <- as.data.frame(as.matrix(coef(lasso_model)))
    coefficients$Variable <- rownames(coefficients)
    rownames(coefficients) <- NULL
    colnames(coefficients)[1] <- "Estimates"
    coefficients <- coefficients[, c("Variable", "Estimates", setdiff(names(coefficients), c("Estimates", "Variable")))]
    
    # store coef results in list
    lasso_coef[[index]] <- coefficients
  }
  
  # return the list of coefficients for all imputed datasets
  return(lasso_coef)
}

# run the lasso model function on the list of imputed datasets
lasso_coef_results <- lasso_model_function(completed_datasets)
```

```{r}
imputed_coefs_list <- list()

for (i in seq_along(lasso_coef_results)) {
  coefs <- lasso_coef_results[[i]]
  colnames(coefs)[colnames(coefs) == "Estimates"] <- paste0("Estimates_", i)
  imputed_coefs_list[[i]] <- coefs[, c("Variable", paste0("Estimates_", i))]
}

# Combine all imputed datasets' coefficients by column
wide_format_coefficients <- Reduce(function(x, y) merge(x, y, by = "Variable", all = TRUE), imputed_coefs_list)
wide_format_coefficients$Pooled_Estimate <- rowMeans(wide_format_coefficients[ , grep("Estimates_",
                                                                                      names(wide_format_coefficients))], 
                                                     na.rm = TRUE)
```

```{r}
long_data_train <- data.frame()
long_data_test <- data.frame()
set.seed(2550)
train_index <- createDataPartition(new_data$trt, p = 0.7, list = FALSE)

for (i in seq_len(imputed_data$m)) {
  imputed_dataset <- complete(imputed_data, i)
  train_set <- imputed_dataset[train_index, ]
  test_set <- imputed_dataset[-train_index, ]
  
  long_data_train <- rbind(long_data_train, train_set)
  long_data_test <- rbind(long_data_test, test_set)
}
```

```{r}
# create the design matrix with interaction terms
long_data_matrix <- model.matrix(abst ~ trt * (age_ps + sex_ps + inc + edu + ftcd_score + ftcd.5.mins +
                                                 bdi_score_w00 + cpd_ps + crv_total_pq1 + hedonsum_n_pq1 +
                                                 hedonsum_y_pq1 + shaps_score_pq1 + otherdiag + antidepmed +
                                                 mde_curr + NMR + Only.Menthol + readiness + race),
                                 data = long_data_train)

# convert the design matrix to a data frame
long_data_trainset <- as.data.frame(long_data_matrix)

# extract the intercept from pooled coefficients
pooled_intercept <- wide_format_coefficients %>%
  filter(Variable == "(Intercept)") %>%
  pull(Pooled_Estimate)

# extract only non-intercept pooled coefficients
pooled_coefs <- wide_format_coefficients %>%
  filter(Variable != "(Intercept)")

# ensure the predictor variables in the data match those in pooled coefficients
predictor_vars <- pooled_coefs$Variable
long_data_trainset <- long_data_trainset[, predictor_vars, drop = FALSE]  # Select only predictor variables

# calculate log-odds using matrix multiplication with pooled coefficients
long_data_trainset$log_odds <- pooled_intercept + as.matrix(long_data_trainset) %*% pooled_coefs$Pooled_Estimate

# convert log-odds to probabilities
long_data_trainset$predicted_prob <- 1 / (1 + exp(-long_data_trainset$log_odds))
```

```{r}
auc_result <- roc(long_data_train$abst, long_data_trainset$predicted_prob)

# Print the AUC value
print(paste("AUC:", auc(auc_result)))

# Optionally, plot the ROC curve
plot(auc_result, main = "ROC Curve for Predicted Probabilities on Training Data")
```
